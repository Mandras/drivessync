var destextra = 0;
var actions = 0;
var output = "";
var int = 0;
var tree;

var file_copied = 0;
var files_to_copy = [];
var copying = false;

function in_array(tab, name) {
    for (var i = 0; i < tab.length; i++) {
        if (tab[i].name == name) return (i);
    }
    return (-1);
}

function stopInterval() {
    clearInterval(int);
}

module.exports = {
    copydir: function (source, destination) {
        console.log('Copy directory ' + source + ' to ' + destination);

        var fs = require('fs');

        output += '<span class="normal">Create directory <b>' + source.substring(source.lastIndexOf('\\') + 1) + '</b> to <b>' + destination.substring(destination.lastIndexOf('\\') + 1) + '/</b></span><br />';

        fs.mkdir(destination + '\\' + source.substring(source.lastIndexOf('\\') + 1), parseInt('0777', 8), function(er) { });
        this.sync_dirs(source, destination + '\\' + source.substring(source.lastIndexOf('\\') + 1));
    },
    copy: function (source, destination) {
        process.stdout.clearLine();
        process.stdout.cursorTo(0);
        console.log('Copy file ' + source + ' to ' + destination);
        output += '<span class="normal">Copy file <b>' + source.substring(source.lastIndexOf('\\') + 1) + '</b> to <b>' + destination.substring(destination.lastIndexOf('\\') + 1) + '/</b></span><br />';

        var fs = require('fs');

        var dest = destination + '\\' + source.substring(source.lastIndexOf('\\') + 1);
        var file_copied_init = file_copied;

        fs.createReadStream(source).pipe(fs.createWriteStream(destination + '\\' + source.substring(source.lastIndexOf('\\') + 1))).on('close', function () {
            file_copied++;


            for (var i = 0; i < files_to_copy.length; i++) {
                if (files_to_copy[i].work == 0) {
                    files_to_copy[i].work = 1;
                    tree.copy(files_to_copy[i].source, files_to_copy[i].destination);
                    break ;
                }
            }
        });
    },
    delete: function (location, tolog) {
        console.log('Delete file ' + location);

        var fs = require('fs');

        fs.unlinkSync(location);

        if (tolog) {
            console.log('Delete EXTRA file: ' + location);
            output += '<span class="normal">Delete <b>extra</b> file <b>' + location.substring(location.lastIndexOf('\\') + 1) + '/</b></span><br />';
        }
    },
    deletefolder: function(location) {

        var fs = require('fs');

        var file_to_del = [];
        var folders_to_del = [];

        if (fs.existsSync(location)) {
            fs.readdirSync(location).forEach(function(file, index){

                var curPath = location + "/" + file;
                if (fs.lstatSync(curPath).isDirectory())
                    folders_to_del.push(curPath);
                else
                    file_to_del.push(curPath);
            });

            for (var i = 0; i < file_to_del.length; i++) {
                this.delete(file_to_del[i], true);
            }

            for (var i = 0; i < folders_to_del.length; i++) {
                this.deletefolder(folders_to_del[i]);
            }

            fs.rmdirSync(location);
        }
    },
    sync_dirs: function (source, destination) {
        var d_source = this.get_directory(source);
        var d_destination = this.get_directory(destination);

        for (var i = 0; i < d_source.length; i++) {

            var inar = in_array(d_destination, d_source[i].name);

            if (inar === -1 && d_source[i].type == "directory")
                this.copydir(d_source[i].location, destination);
            else if (inar === -1 && d_source[i].type == "file") {
                files_to_copy.push({"source": d_source[i].location, "destination": destination, "work": 0});
                actions++;
            }
                // this.copy(d_source[i].location, destination);
            else if (inar >= 0 && d_source[i].size != d_destination[inar].size && d_source[i].type == "file") {
                this.delete(d_destination[inar].location, false);
                this.copy(d_source[i].location, destination);
            }
            else if (inar >= 0 && d_source[i].type == "directory") {
                this.sync_dirs(d_source[i].location, d_destination[inar].location);
            }
        }

        if (destextra == 1) {
            for (var i = 0; i < d_destination.length; i++) {

                var inar = in_array(d_source, d_destination[i].name);

                if (inar === -1  && d_destination[i].type == "file")
                    this.delete(d_destination[i].location, true);
                else if (inar === -1  && d_destination[i].type == "directory")
                    this.deletefolder(d_destination[i].location);
            }
        }
    },
    get_directory: function (location) {
        var path = require('path');
        var mime = require('mime');
        var fs = require('fs');

        var directory_content_folders = new Array();
        var directory_content_files = new Array();

        var files = fs.readdirSync(location);

        for (var i in files) {
            if (files[i] != 'System Volume Information' && files[i] != '.' && files[i] != '..' && files[i].length > 0 && files[i][0] != '$') {
                file = path.resolve(location, files[i]);

                var type = 'file';

                var stat = fs.lstatSync(file);
                if (stat && stat.isDirectory()) type = 'directory';

                var size = stat.size;

                var filename = file.substring(file.lastIndexOf('\\') + 1);

                var file_data = {
                    'location': file,
                    'name': filename,
                    'type': type,
                    'size': size
                };

                if (type == 'directory') directory_content_folders.push(file_data);
                else directory_content_files.push(file_data);
            }
        }

        return (directory_content_folders.concat(directory_content_files));
    },
    sync: function (request, response, next, treeaddr) {

        tree = treeaddr;

        var url = require('url');

        var url_parts = url.parse(request.url + '?' + request.post, true);
        var post = url_parts.query;

        destextra = parseInt(post["destextra"]);
        var source = post["source"];
        var destination = post["destination"];

        this.sync_dirs(source + '\\', destination + '\\');

        if (actions > 0) {

            files_to_copy[0].work = 1;
            this.copy(files_to_copy[0].source, files_to_copy[0].destination);
            int = setInterval(function() {
                if (file_copied == 0) var percent = 0;
                else var percent = file_copied * 100 / actions;

                process.stdout.clearLine();
                process.stdout.cursorTo(0);
                process.stdout.write('Progression: ' + parseFloat(Math.round(percent * 100) / 100).toFixed(2) + '%');

                // END

                if (actions == file_copied) {
                    stopInterval();
                    output = "";
                    response.send('<span class="success">Work done with <b>' + actions + '</b> new files.</span><br />');

                    copying = false;
                    file_copied = 0;
                    destextra = 0;
                    actions = 0;
                    int = 0;
                }
            }, 500);
        }
        else {

            // END

            response.send('<span class="success">Nothing to do.</span><br />');
            destextra = 0;
            output = "";
        }

    },
    get_drives: function(request, response, next) {
        var spawn = require('child_process').spawn;
        var list  = spawn('cmd');
        var d;

        list.stdout.on('data', function (data) {
            var drivestmp = ('' + data).split('\r\r');

            for (var i = 0; i < drivestmp.length; i++) {
                if (drivestmp[i][0] != '\n' || drivestmp[i] == '\n') drivestmp[i] = null;
            }

            var drives = [];

            for (var i = 0; i < drivestmp.length; i++) {
                if (drivestmp[i] != null && drivestmp[i].length > 0) {
                    if (drivestmp[i].indexOf(':') > -1) {

                        drivestmp[i] = drivestmp[i].replace_all('\'', '');
                        drivestmp[i] = drivestmp[i].replace_all(' ', '');
                        drivestmp[i] = drivestmp[i].replace_all('\n', '');
                        drivestmp[i] = drivestmp[i].replace_all('[', '');
                        drivestmp[i] = drivestmp[i].replace_all(']', '');

                        var tab = drivestmp[i].split(',');

                        for (var j = 0; j < tab.length; j++) {
                            if (tab[j].length > 0 && tab[j] != null)
                                drives.push(tab[j]);                            
                        }
                    }
                }
            }

            if (drives.length == 0) return ;

            response.send(JSON.stringify(drives));
        });

        list.stdin.write('wmic logicaldisk get name\n');
        list.stdin.end();

    },
    msg: function(request, response, next) {
        if (output.length > 0) {
            var tosend = output;
            output = '';

            response.send(tosend);
        }
        else response.send('');
    }
};
